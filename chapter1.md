# 1. Reactive Way

Наш реальный мир довольно сложно устроен: события происходят в случайном порядке, постоянные сбои приложений, а так же сетей. Лишь немногая часть приложений имею синхронный поток выполнения, и мы вынуждены писать асинхронный код для того, чтобы приложения были отзывчивыми для пользователей. Писать асинхронный код по мере увеличения сложности приложений становиться все сложнее. В общем это боль и мука. Но! Это не должно быть так...

Современные приложения должны быть супер-пупер-мега отзывчивыми и иметь возможность обрабатывать данные из различных источников в одно и тоже время. Имеющиеся на данный момент техники в современном JavaScript ни как не приведут нас к желаемому. Они тупо не позволяют маштабировать наш код потому, что этот самый код экспоненциально усложняется, ведь мы добавляем параллелизм, а еще у нас появилось состояние приложения.

В это главе мы познакомимся с реактивным программированием. С парадигмой, которая позволит более простым и естественным спобом думать о асинхронном коде. Я покажу вам, как потоки событий, которые мы называем Observables — являются прекрасным способом обработки событий. Затем мы с вами создадим Observable и посмотрим, как "реактивное мышление" и RxJS в значительной степени улучшают текущие техники. Это сделает ваш фейс более радостным, ведь боль уйдет, а так же это поможет вам стать более продуктивным разработчиком. Юху!

## А "реактивный" - это вообще что? {#11}

Давайте начнем с рассмотрения небольшой "реактивной" программы RxJS. Эта программа должна получать данные из разных источников одним нажатием кнопки, и она имеет следующие требования:

* Программа должна объединять данные из двух разных источников, которые возвращают разные структуры в JSON.
* Финальный результат обработки не должен содержать каких-либо дубликатов.
* Чтобы пользователь не мог жать на кнопку как дурак по многу раз, тем самым делая кучу запросов, мы будет разрешать нажимать только один раз в секунду времени. Короче, блокировать мы ему будем кнопку.

Используя RxJS мы бы написали, что-то такое:

```js
const button = document.getElementById('retrieveDataBtn')

const source1 = Rx.DOM.getJSON('/resource1').pluck('name')
const source2 = Rx.DOM.getJSON('/resource2').pluck('props', 'name')
const clicks = Rx.Observable.fromEvent(button, 'click')


function getResults(amount) {
    return source1
        .merge(source2)
        .pluck('names')
        .flatMap(array => Rx.Observable.from(array))
        .distinct()
        .take(amount)
}

clicks.debounce(1000)
    .flatMap(getResults(5))
    .subscribe(
        (value) => console.log('Received value', value),
        (err) => console.error(err),
        () => console.log('All values retrieved!')
    );
```

Не беспокойтесь о том, что вы ни черта не понимаете, что тут творится. Ну во-первых, если бы мы использовали обычные техники обработки всего этого добра, то у нас была бы портянка в разы больше. А тут мы используем Observables, что позволяет это сделать более компактно. Круто! Не правдали? _\(прим. от переводчика: автор книги не предоставил противопоставляющего примера, по-этому как бы так себе утверждение\)_

По сути, Observable, представляет собой так называемый "поток данных". Программы могут быть выражены как потоки данных. В предыдущем примере оба удаленных источника - Observables, также как и щелчки мыши у пользователя. На самом деле, наша программа по существу представляет собой единый объект Observable, созданный на основе события нажатия кнопки, которое мы трансформируем для получения желаемых результатов.

Реактивное программирование придает коду выразительность. Возьмем, к примеру, "тормозилку" щелчков мышью в нашем примере. Представьте себе, насколько сложно было бы сделать это, используя callbacks или Promises: нам нужно было бы сбрасывать таймер каждую секунду и сохранять состояние о том, прошла ли секунда с момента последнего нажатия пользователем кнопки. Это очень сложная задача для столь маленьких функций, и код для нее даже не связан с фактической функциональностью вашей программы. В больших приложениях эти небольшие сложности складываются очень быстро, чтобы создать запутанную базу кода.

При реактивном подходе мы используем метод debounce для торможения потока кликов. Это гарантирует, что между каждыми щелчками есть хотя бы одна секунда, и отбрасывает любые клики между ними. Нам все равно, как это происходит внутри страны; Мы просто выражаем то, что хотим сделать наш код, а не то, как это сделать.

Это становится намного интереснее. Далее вы увидите, как реактивное программирование помогает нам сделать наши программы более эффективными и выразительными.

