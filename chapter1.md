# 1. Reactive Way

Наш реальный мир довольно сложно устроен: события происходят в случайном порядке, постоянные сбои приложений, а так же сетей. Лишь немногая часть приложений имею синхронный поток выполнения, и мы вынуждены писать асинхронный код для того, чтобы приложения были отзывчивыми для пользователей. Писать асинхронный код по мере увеличения сложности приложений становиться все сложнее. В общем это боль и мука. Но! Это не должно быть так...

Современные приложения должны быть супер-пупер-мега отзывчивыми и иметь возможность обрабатывать данные из различных источников в одно и тоже время. Имеющиеся на данный момент техники в современном JavaScript ни как не приведут нас к желаемому. Они тупо не позволяют маштабировать наш код потому, что этот самый код экспоненциально усложняется, ведь мы добавляем параллелизм, а еще у нас появилось состояние приложения.

В это главе мы познакомимся с реактивным программированием. С парадигмой, которая позволит более простым и естественным спобом думать о асинхронном коде. Я покажу вам, как потоки событий, которые мы называем Observables — являются прекрасным способом обработки событий. Затем мы с вами создадим Observable и посмотрим, как "реактивное мышление" и RxJS в значительной степени улучшают текущие техники. Это сделает ваш фейс более радостным, ведь боль уйдет, а так же это поможет вам стать более продуктивным разработчиком. Юху!

## А "реактивный" - это вообще что? {#фф}

Давайте начнем с рассмотрения небольшой "реактивной" программы RxJS. Эта программа должна получать данные из разных источников одним нажатием кнопки, и она имеет следующие требования:

* Программа должна объединять данные из двух разных источников, которые возвращают разные структуры в JSON.
* Финальный результат обработки не должен содержать каких-либо дубликатов.
* Чтобы пользователь не мог жать на кнопку как дурак по многу раз, тем самым делая кучу запросов, мы будет разрешать нажимать только один раз в секунду времени. Короче, блокировать мы ему будем кнопку.

Используя RxJS мы бы написали, что-то такое:

```js
const button = document.getElementById('retrieveDataBtn')
const source1 = Rx.DOM.getJSON('/resource1').pluck('name')
const source2 = Rx.DOM.getJSON('/resource2').pluck('props', 'name')

function getResults(amount) {
    return source1.merge(source2)
        .pluck('names')
        .flatMap(array => Rx.Observable.from(array))
        .distinct()
        .take(amount)
}

const clicks = Rx.Observable.fromEvent(button, 'click')

clicks.debounce(1000)
    .flatMap(getResults(5))
    .subscribe(
        (value) => console.log('Received value', value),
        (err) => console.error(err),
        () => console.log('All values retrieved!')
    );
```

Не беспокойтесь о том, что вы ни черта не понимаете, что тут твориться. Ну во-первых, если бы мы использовали обычные техники обработки всего этого добра, то у нас была бы портянка в разы больше. А тут мы используем Observables, что позволяет это сделать более компактно. Круто! Не правдали? _\(прим.: автор книги не предоставил противопоставляющего примера, по-этому как бы так себе утверждение\)_

